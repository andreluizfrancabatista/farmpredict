# -*- coding: utf-8 -*-
"""farmpredict.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12Bsi8z68wqCis0hts9YYfT7ea8Gsj2fE
"""

import pandas as pd
from datetime import datetime, time

# Mostrar todas as colunas
pd.set_option('display.max_columns', None)

# Mostrar todas as linhas (cuidado com DataFrames grandes!)
pd.set_option('display.max_rows', None)

# Evitar truncamento de colunas largas
pd.set_option('display.max_colwidth', None)

# Lê o CSV
url = 'https://raw.githubusercontent.com/andreluizfrancabatista/farmpredict/main/data/painel.csv'
df = pd.read_csv(url)

# Adiciona colunas zeradas
df['Toneladas por dia (acumulada)'] = 0
df['Toneladas por hora'] = 0
df['Tempo produtivo (acumulado)'] = 0.0  # em horas (float)
df['Toneladas por hora efetiva'] = 0

# Remove colunas desnecessárias
colunas_remover = [
    'Descrição Regional', 'Descrição da Unidade', 'Descrição do Equipamento',
    'Código de Operador', 'Nome', 'Código da Operação', 'Descrição da Operação',
    'Código da Fazenda', 'Código da Zona', 'Código do Talhão', 'Descrição da Fazenda',
    'Horímetro/Odometro Inicial', 'Horímetro/Odometro Final', 'Horímetro/Odometro Secundário',
    'Velocidade Média'
]
df.drop(columns=colunas_remover, inplace=True)

# Converte 'Data Hora Local' para datetime (dd/mm/yyyy hh:mm:ss)
df['Data Hora Local'] = pd.to_datetime(df['Data Hora Local'], dayfirst=True, errors='coerce')

# Concatena data com hora inicial/final (que podem estar no formato HH:MM:SS)
df['Hora Inicial'] = pd.to_datetime(
    df['Data Hora Local'].dt.date.astype(str) + ' ' + df['Hora Inicial'],
    errors='coerce'
)

df['Hora Final'] = pd.to_datetime(
    df['Data Hora Local'].dt.date.astype(str) + ' ' + df['Hora Final'],
    errors='coerce'
)

# Calcula tempo da operação em horas
df['tempo_operacao'] = (df['Hora Final'] - df['Hora Inicial']).dt.total_seconds() / 3600

# Marca tempo produtivo quando operação for PRODUTIVA
df['tempo_produtivo'] = df.apply(
    lambda row: row['tempo_operacao'] if str(row['Descrição do Grupo da Operação']).strip().upper() == 'PRODUTIVA' else 0,
    axis=1
)

# Calcula tempo produtivo acumulado (sem alterar ordem)
df['Tempo produtivo (acumulado)'] = df.groupby('Código Equipamento')['tempo_produtivo'].cumsum()

# Remove colunas auxiliares
df.drop(columns=['tempo_operacao', 'tempo_produtivo'], inplace=True)

# Converte horas decimais para timedelta e formata hh:mm:ss
df['Tempo produtivo (acumulado)'] = pd.to_timedelta(df['Tempo produtivo (acumulado)'], unit='h')
df['Tempo produtivo (acumulado)'] = df['Tempo produtivo (acumulado)'].astype(str).str.extract(r'(\d{2}:\d{2}:\d{2})')[0]


def format_timedelta_sem_days(td_series):
    total_seconds = td_series.dt.total_seconds().astype(int)
    horas = total_seconds // 3600
    minutos = (total_seconds % 3600) // 60
    segundos = total_seconds % 60
    return horas.astype(str).str.zfill(2) + ':' + \
           minutos.astype(str).str.zfill(2) + ':' + \
           segundos.astype(str).str.zfill(2)

def tempo_produtivo_no_horario(df, horario_str):
    from datetime import datetime
    horario_time = datetime.strptime(horario_str, '%H:%M').time()

    def esta_no_intervalo(row):
        hi = row['Hora Inicial'].time()
        hf = row['Hora Final'].time()
        return hi <= horario_time < hf

    df_filtrado = df[df.apply(esta_no_intervalo, axis=1)].copy()
    df_filtrado['Tempo produtivo (acumulado)'] = pd.to_timedelta(df_filtrado['Tempo produtivo (acumulado)'])

    resultado = df_filtrado.groupby('Código Equipamento')['Tempo produtivo (acumulado)'].max()
    # Aplica formatação sem '0 days'
    resultado_fmt = format_timedelta_sem_days(resultado)

    return resultado_fmt

# Função para formatar timedelta como hh:mm:ss sem "0 days"
def format_timedelta_sem_days(td_series):
    total_seconds = td_series.dt.total_seconds().astype(int)
    horas = total_seconds // 3600
    minutos = (total_seconds % 3600) // 60
    segundos = total_seconds % 60
    return horas.astype(str).str.zfill(2) + ':' + \
           minutos.astype(str).str.zfill(2) + ':' + \
           segundos.astype(str).str.zfill(2)

# Loop para as horas de 01h até 23h
for h in range(1, 24):
    hora_referencia = time(h, 0)  # Ex: 01:00

    # Filtra onde o horário está entre Hora Inicial e Hora Final
    df_hora = df[
        (df['Hora Inicial'].dt.time <= hora_referencia) &
        (df['Hora Final'].dt.time > hora_referencia)
    ].copy()


    # Garante tipo timedelta para a coluna acumulada
    df_hora['Tempo produtivo (acumulado)'] = pd.to_timedelta(df_hora['Tempo produtivo (acumulado)'], errors='coerce')

    # Extrai data e hora como colunas separadas
    df_hora['Data'] = df_hora['Data Hora Local'].dt.date.astype(str)
    df_hora['Hora'] = hora_referencia.strftime('%H:%M')

    # Agrupa para manter o maior valor acumulado naquele horário
    df_final = df_hora.groupby(
        ['Descrição do Grupo de Equipamento', 'Código Equipamento', 'Data', 'Hora', 'Descrição do Grupo da Operação'],
        as_index=False
    ).agg({
        'Toneladas por dia (acumulada)': 'max',
        'Toneladas por hora': 'max',
        'Tempo produtivo (acumulado)': 'max',
        'Toneladas por hora efetiva': 'max'
    })

    # Formata tempo produtivo acumulado
    df_final['Tempo produtivo (acumulado)'] = format_timedelta_sem_days(df_final['Tempo produtivo (acumulado)'])

    # Gera o nome do arquivo
    nome_arquivo = f'../data/painel-{h:02d}h00.csv'

    # Salva o arquivo CSV
    df_final.to_csv(nome_arquivo, index=False, encoding='utf-8-sig')

    print(f"Arquivo salvo: {nome_arquivo}")